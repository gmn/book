#!/usr/bin/env python3

"""
this is an app to keep track of my endlessly evolving todolists

Item:
    t: item
    title:
    comments:
    added:
    finished:

List:
    t: list
    name:
    comments:
    items: []

- support for chained dependencies, meaning:
    - buy a house
    - if I buy a house, buy a sofa
    - once we have a sofa, buy a dog

    one isn't relative until its precursor is accomplished: Triggers?
"""

import sys, os, json, re, random

TODO_PATH = '/home/gnaughto/Private/logs/databases/todo.json'
QUERYABLE_PATH = '/home/gnaughto/code/pyqueryable'

sys.path.append(QUERYABLE_PATH)
from Queryable import db_object

# globals
p    = lambda X: print( str(X) )
db   = db_object(path=TODO_PATH, jsonarg={'sort_keys':True,'indent':2}).load()
config = {}


def print_item( i, item, longprint, Lists ):
    if longprint:
        p(item.toString(index='{}:'.format(i+1), lists=Lists.data))
    else:
        p('{}: {}'.format((i+1), item.shortString()))

def print_list( r, backwards, longprint, Lists ):
    p('-' * 39)
    p('+ items in "{}"'.format(r['name']))
    p('-' * 39)
    generator = reversed(r['items']) if backwards else r['items']
    for i, b in enumerate( generator ):
        bb = db.find({'_id':b['_id']})
        if bb.count():
            bk = Iook(**bb.data[0])
            print_item( i, bk, longprint, Lists )

def show_all_items( title, args ):
    order = 1 if title == '-r' or '-r' in args else -1
    res = db.find({'_t':'item','finished':{'$exists':False}}).sort({'added':order})
    lists = db.find({'_t':'list'}).sort({'name':1})
    longprint = True if title == '-l' or '-l' in args else False

    for index, item in ((i, Item(**r)) for i, r in enumerate(res.data[:LIST_LIMIT])):
        print_item( index, item, longprint, lists )

# object equal
def objeq( x, y ):
    unmatched = set(x.items()) ^ set(y.items())
    return len(unmatched) == 0

def item_from_index_title( title ):
    def from_title( title ):
        res = db.find({'_t':'item', 'title':title})
        if res.count() != 1:
            return False
        return Item( **res.data[0] )

    try:
        index = int(title)
    except:
        return from_title( title )

    res = db.find({'_t':'item', '_id':index})
    if res.count() != 1:
        return from_title( title )
    return Item( **res.data[0] )

def list_from_index_name( name ):
    def from_name( name ):
        res = db.find({'_t':'list', 'name':name})
        if res.count() != 1:
            return False
        return res.data[0]

    try:
        index = int(name)           # try to cast it
    except:
        return from_name( name )    # if not must be name or nothing

    res = db.find({'_t':'list', '_id':index})
    if res.count() != 1:
        return from_name( name )
    return res.data[0]


class Item:
    # dates
    title = ''
    added = ''
    finished = ''
    comments = ''
    index = 0           # 0 is no index, not set
    _t = ''
    _id = ''
    attribs = ('_id', 'title', 'added', 'finished', 'comments', 'index')

    def __init__(self,title=None, added=None, finished=None, comments=None, index=None,_t=None,_id=None):
        if title:
            self.title = title
        if added:
            self.added = added
        if finished:
            self.finished = finished
        if comments:
            self.comments = comments
        if index:
            self.index = index
        if _t:
            self._t = _t
        if _id:
            self._id = _id

    #
    # dictionary-like interfaces
    #
    def __getitem__(self, key):
        if key not in self.attribs:
            return None
        return self.__getattribute__(key)

    def __setitem__(self, key, value):
        if key in self.attribs:
            self.__dict__[key] = value

    def __contains__(self, key):
        if key not in self.attribs:
            return False
        return True if self.__getattribute__(key) else False

    def __len__(self):
        length = 0
        for key in self.attribs:
            if self.__getattribute__(key):
                length = length + 1
        return length

    def keys(self):
        return self.attribs

    def items(self):
        a = []
        for key in self.attribs:
            val = self.__getattribute__(key)
            if val:
                a.append( {key:val} )
        return a

    #
    # accessors
    #
    def insert( self, db ):
        if self.check_exists(db):
            return False
        obj = {'_t':'item'}
        for i in self.attribs[1:]:
            e = self.__getattribute__(i)
            if e:
                obj[i] = e
        db.insert(obj)
        return True

    def check_exists( self, db ):
        obj = {'_t':'item'}
        for i in ['title']:
            e = self.__getattribute__(i)
            if e:
                obj[i] = e
        if not obj.get('title'): # not exist or unset. must have title.
            return False
        res = db.find(obj)
        return res.count() == 1

    def toString(self, index=' -', lists=[]):
        s = ''
        for i in Item.attribs:
            e = self.__getattribute__(i)
            if e:
                s = '{}{} {:11s}: {}\n'.format(s, (index if i=='_id' else ' -'), i, e)
        if lists and self._id is not None:
            list_names = []
            for lst in lists:
                if self._id in lst['items']:
                    list_names.append(lst['name'])
            if list_names:
                s = '{} - member of  : {}\n'.format(s, ', '.join(list_names))
        return s

    def shortString(self):
        s = '[{}]'.format(self._id) if self._id else ''
        s = '{} {}'.format(s, self.title)
#        for i in ('author','year'):
#            e = self.__getattribute__(i)
#            if e:
#                s = '{}{}'.format( s, (' - '+e) if s else e )
        return s


def new_item( title, args ):
    obj = {'_t':'item','title':title,'added':'now()'}
    comments = False
    if args:
        obj['comments'] = comments = args[0]
    for i in ['title','comments']:
        if (i == 'title' and title) or (i == 'comments' and comments):
            continue
        rn = input('{} > '.format(i))
        if rn:
            obj[i] = rn

    b = Item(**obj)
    if not b.title:
        p( 'item must have at least a title ')
        return
    if not b.insert(db):
        p('"{}" already exists'.format(title))
        return
    db.save()

    res = db.find({'title':title})
    if res.count() > 0:
        c = Item(**res.data[0])
        p('Adding:\n{}'.format(c.toString()) )


def add_item_to_list( title, args ):
    if not title:
        p( 'must provide a title')
        return
    if not args:
        p( 'must provide a list')
        return

    item_id = -1   # int
    List = {}   # dict

    # ITEM
    item = item_from_index_title( title )
    if not item:
        p('** error: item must be index or title')
        return
    item_id = item['_id']

    # FOR LISTS
    for arg in args:
        # LIST
        List = list_from_index_name( arg )
        if not List:
            p('** error: list must be index or name')
            return

        # see if the item is already in List
        if item_id in List['items']:
            p('** warning: "{}" is already in list "{}"'.format(item['title'],List['name']))
        else:
            List['items'].append(item_id)
            db.update({'_t':'list','name':List['name']},{'$set':{'items':List['items']}})
            db.save()
            p('"{}" added to "{}"'.format(item['title'], List['name']) )


def finish_item(title):
    item = item_from_index_title( title )
    if not item:
        p('** error: item must be index or title')
        return
    item_id = item['_id']

    if item['finished']:
        p('"{}" already marked finished'.format(item['title']))
        return

    db.update({'_id':item_id},{'$set':{'finished':'now()'}})
    db.save()
    res = db.find({'_id':item_id})
    d = res.data[0]
    p( '"{}" marked finished on "{}"'.format(d['title'],d['finished']) )


def default_action(op, title, args):
    # if op is a list name, show the items in the list
    if not op and not title:
        f = config.get('default_action')
        f = globals().get(f)
        a = config.get('default_args')
        if f and a == 3:
            f(op, title, args)
        elif f and a == 2:
            f(title, args)
        elif f and a == 0:
            f()
        else:
            p('no default action set')
        return

    res = db.find({'_t':'list'})
    for r in res.data:
        if r['name'] == op.lower() or op.lower() == 'all': # found it
            p('-' * 39)
            p('+ items in "{}"'.format(r['name']))
            p('-' * 39)
            for i, b in enumerate( r['items'] ):
                bb = db.find({'_id':b['_id']}).sort({'_id':1})
                if bb.count():
                    bk = Item(**bb.data[0])
                    p(bk.toString(index='{}:'.format(i+1)))
            if op.lower() != 'all':
                break


def listadd(title, args):
    ## sanity check args
    o = {'_t':'list','items':[],'name':title}
    if not title:
        rn = input('name > ')
        if rn:
            o['name'] = rn.lstrip().rstrip()

    ## empty?
    if not o.get('name'):
        p('** error: list cant have empty name')
        return

    ## check if already exists
    res = db.find({'_t':'list','name':o['name']})
    if res.count() > 0:
        p('** error: list "{}" already exists'.format(o['name']))
        return

    ## confirm
    yn = input('sure you want to create new list "{}" y/N? '.format(o['name']))
    if not yn.lower().startswith('y'):
        p('bailing')
        return

    ## add it & save
    db.insert(o).save()

    ## report
    res = db.find({'_t':'list','name':o['name']})
    if res.data:
        p( 'list created: "[{}] {}"'.format(res.data[0]['_id'],res.data[0]['name']) )


def load_config():
    res = db.find({'_t':'config'})
    if res.count() == 0:
        p('Error: no config!')
        sys.exit(0)

    global config
    config = res.data[0].get('settings', {})

def set_defaults():
    global op
    global LIST_LIMIT
    global title
    global args
    z = 1000000
    D = LIST_LIMIT = config.get( 'default_rows', z )
    if '--limit' == op:
        op = ''
        LIST_LIMIT = title
        title = ''
    elif '--limit' == title:
        LIST_LIMIT = args.pop(0)
        title = ''
    elif '--limit' in args:
        i = args.index('--limit')
        args.pop(i)
        LIST_LIMIT = args.pop(i)

    try:
        LIST_LIMIT = int(LIST_LIMIT)
    except:
        LIST_LIMIT = D


def print_help():
    p("""Usage:
  --help, -h              show this help
  all                     show all items
  new    [-n]             add a new item
  add    [-a]             add a item to a list
  lists                   show all lists
  finish [-f]             mark an  item finished
  listadd                 add a new list
  [list name][all]        show items in a list, or all items in all lists

  general:
    --limit N             limit number of results returned in listing queries
""")


##############################################
#
# entry point
#
##############################################

# arguments
op   = sys.argv[1:2]
op = '' if len(op) == 0 else op.pop().lower()
title = sys.argv[2:3]
title = '' if len(title) == 0 else title.pop()
args = sys.argv[3:]

load_config()

set_defaults()


if op == '-h' or op == '--help':
    print_help()

# show all items
elif op == 'all' or '-a' == op:
    LIST_LIMIT = 1000000
    show_all_items( title, args )

# new item
elif op == 'new' or op == '-n':
    new_item( title, args )

# add item to list
elif op == 'add':
    add_item_to_list( title, args )

elif op == 'listadd':
    listadd(title, args)

# show lists
elif op == 'lists':
    res = db.find({'_t':'list'}).sort({'_id':1})
    for i, r in enumerate(res.data):
        p('{}: [{}] {}'.format( i+1, r['_id'], r['name'] ) )

# mark item finished
elif op == 'finish' or op == '-f':
    finish_item(title)

else:
    default_action(op, title, args)

